function [ThudChain, ShatterChain] = gb_model_2020_09_09(ramp, ...
																												 gain, ...
																												 nnThudParams, ...
																												 nnShatterParams)

	FeatureChain = ConstructFeatureChain(ramp,gain);

	if nargin < 3
		% Didn't receive neural net parameters,
		% so return feature chain for training
		ThudChain = FeatureChain;
		ShatterChain = [];
	else

		% Otherwise build the full chain
		net_eval_thud=ramp.learn.nn('nn',nnThudParams);
		net_eval_zcr=ramp.learn.nn('nn',nnShatterParams);
		Chain_thud=FeatureChain ...
							 > net_eval_thud;
		Chain_zcr=FeatureChain ...
							> net_eval_zcr;
		PULSE=ramp.ops.pulse('time',1e-3);
		% This operator is used to create a wide pulse
		Hang=ramp.ops.overhang('up',1e3, 'down',10);
		Pass=ramp.ideal.pass();

		% Adapting threshold and overhang into the chain
		Mid = 2.5/2;
		CMPMID=ramp.ops.cmp('thresh',Mid);
		NOT = ramp.logic.gate('type','not');
		AND = ramp.logic.gate('type','and');
		Chain_thresh_thud= Chain_thud ...
											 >  ramp.ops.cmp('thresh',0.2);
		Chain_thresh_zcr = Chain_zcr ...
											 >  ramp.ops.cmp('thresh',0.2);

		% Overhang(ramp, [1e3 10], Mid)
		Chain_hang_zcr= Chain_thresh_zcr  ...
										> Hang ...
										> CMPMID;

		% Thuds that are not preceded by shatter(ZCR)
		% Overhang(ramp, [20 100], Mid)
		Chain_validThud=[Chain_hang_zcr ...
										 > ramp.ops.overhang('up',20, 'down',100) ...
										 > CMPMID ...
										 > NOT;Chain_thresh_thud] ...
										> AND;  %Hang changed here

		% Overhang(ramp, [1e3 10], Mid)
		Chain_hangvalidThud=Chain_validThud ...
												> Hang ...
												> CMPMID;
		Chain_validZCR=[Chain_hangvalidThud;Chain_thresh_zcr] ...
									 > AND;
		Chain_declareThud_tmp = Chain_validThud  ...
														> PULSE;
		Chain_declareShatter_tmp = Chain_validZCR  ...
															 > PULSE;

		% Overhang(ramp, [1e3 10], 0.2)
		Chain_declareShatter_tmp2=[Chain_declareThud_tmp ...
															 > ramp.ops.overhang('up',1e3, 'down',10)  ...
															 > ramp.ops.cmp('thresh',.2); ...
															 Chain_declareShatter_tmp] ...
															> AND;

		ShatterChain=Chain_declareShatter_tmp2 ...
								 > Overhang(ramp, [1e3 10], 0.2);
		ThudChain=Chain_declareThud_tmp ...
							> Overhang(ramp, [1e3 10], 0.6)  ...
							> ramp.ops.pulse('time',1e-3);
	end
end

function chain = Overhang(ramp, rates, thresh)
	chain = ramp.ops.overhang('up', rates(1),   'down', rates(2)) ...
					> ramp.ops.cmp('thresh', thresh);
end

function FeatureChain = ConstructFeatureChain(ramp,gain)
	% 4kHz BPF > PkDe > Log > {Pass;Baseline]
	HiFreq = ramp.ops.bpf('fc',4e3, 'Av',gain) ...
					 > ramp.ops.peak('atk',8.13e2, 'dec',143, 'modelVersion','PDmodelDynamic') ...
					 > ramp.ideal.log('in_offset',6e-3) ...
					 > [ramp.ideal.pass(); ...
							ramp.ops.peak('atk',30, 'dec',90, 'modelVersion','PDmodelDynamic')];

	% 400 Hz BPF > PkDe > Log > {Pass;Baseline]
	LoFreq = ramp.ops.bpf('fc',4e2, 'Av',gain) ...
					 > ramp.ops.peak('atk',8.13e2, 'dec',54, 'modelVersion','PDmodelDynamic') ...
					 > ramp.ideal.log('in_offset',6e-3) ...
					 > [ramp.ideal.pass(); ...
							ramp.ops.peak('atk',20, 'dec',90, 'modelVersion','PDmodelDynamic')];

	% Chain generates three outputs
	FeatureChain = [ramp.ops.zcr() > ramp.ideal.amp('Av',.001); ...
									[HiFreq(); HiFreq()] > ramp.ideal.minus(); ...
									[LoFreq(); LoFreq()] > ramp.ideal.minus()];
end
